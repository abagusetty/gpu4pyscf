diff --git a/gpu4pyscf/dft/numint.py b/gpu4pyscf/dft/numint.py
index 8ec2954..9859046 100644
--- a/gpu4pyscf/dft/numint.py
+++ b/gpu4pyscf/dft/numint.py
@@ -95,6 +95,7 @@ def eval_ao(mol, coords, deriv=0, shls_slice=None, nao_slice=None, ao_loc_slice=
         assert ctr_offsets_slice is not None
         ctr_offsets = opt.l_ctr_offsets
 
+    print("ctr_offsets_slice value in eval_ao: ", ctr_offsets_slice.dtype.name, ctr_offsets_slice.flags['C_CONTIGUOUS'], type(ctr_offsets_slice), len(ctr_offsets_slice), ctr_offsets_slice)
     nctr = ctr_offsets.size - 1
     ngrids = coords.shape[0]
     coords = cupy.asarray(coords, order='F')
@@ -103,7 +104,9 @@ def eval_ao(mol, coords, deriv=0, shls_slice=None, nao_slice=None, ao_loc_slice=
 
     if out is None:
         out = cupy.empty((comp, nao_slice, ngrids), order='C')
-        
+
+    print("BEFORE: value of out from eval_ao inbetween block_loop: ", type(out), out.shape, out)
+
     err = libgdft.GDFTeval_gto(
         ctypes.cast(stream.ptr, ctypes.c_void_p),
         ctypes.cast(out.data.ptr, ctypes.c_void_p),
@@ -113,10 +116,11 @@ def eval_ao(mol, coords, deriv=0, shls_slice=None, nao_slice=None, ao_loc_slice=
         ctypes.cast(ao_loc_slice.data.ptr, ctypes.c_void_p),
         ctypes.c_int(nao_slice),
         ctr_offsets.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(nctr),
-        ctr_offsets_slice.ctypes.data_as(ctypes.c_void_p),
+        ctr_offsets_slice.ctypes.data_as(ctypes.POINTER(ctypes.c_int)),
         _sorted_mol._bas.ctypes.data_as(ctypes.c_void_p),
         ctypes.byref(opt.envs_cache))
 
+    print("AFTER: value of out from eval_ao inbetween block_loop: ", type(out), out.shape, out)
     if err != 0:
         raise RuntimeError('CUDA Error in evaluating AO')
 
@@ -149,10 +153,10 @@ def eval_rho(mol, ao, dm, non0tab=None, xctype='LDA', hermi=0,
         buf = cupy.ndarray((nao,ngrids), dtype=dm.dtype, memptr=buf.data)
     if xctype in ('LDA', 'HF'):
         c0 = dm.dot(ao, out=buf)
+        # print("0. c0 in eval_rho(): ", len(c0), c0)
+        # print("0. ao in eval_rho(): ", len(ao), ao)
         rho = _contract_rho(c0, ao)
-        print("LDA/HF rho type in numint.py for eval_rho(): ", type(c0), len(c0), c0.shape, type(ao), len(ao), ao.shape, type(rho), len(rho), rho.shape)
-        # for i in range(len(rho)):
-        #     print(i, rho[i])
+        # print("1. rho in eval_rho(): ", len(rho), rho)
     elif xctype in ('GGA', 'NLC'):
         rho = cupy.empty((4,ngrids))
         c0 = dm.dot(ao[0], out=buf)
@@ -183,7 +187,7 @@ def eval_rho(mol, ao, dm, non0tab=None, xctype='LDA', hermi=0,
             else:
                 rho[i] += _contract_rho(c1, ao[0])
         rho[tau_idx] *= .5  # tau = 1/2 (\nabla f)^2
-
+    # print("2. rho in eval_rho(): ", len(rho), rho)
     return rho
 
 def eval_rho1(mol, ao, mo_coeff, mo_occ, non0tab=None, xctype='LDA',
@@ -236,6 +240,7 @@ def eval_rho2(mol, ao, mo_coeff, mo_occ, non0tab=None, xctype='LDA',
               with_lapl=False, verbose=None, buf=None):
     xctype = xctype.upper()
     cpos = mo_coeff[:,mo_occ>0]
+    print("type from eval_rho2 in numint.py: ", type(cpos), type(mo_occ), type(mo_coeff))    
     cpos *= mo_occ[mo_occ>0]**.5
     return _eval_rho2(ao, cpos, xctype, with_lapl, buf)
 
@@ -457,22 +462,25 @@ def _nr_rks_task(ni, mol, grids, xc_code, dm, mo_coeff, mo_occ,
         ngrids_glob = grids.coords.shape[0]
         grid_start, grid_end = gen_grid_range(ngrids_glob, device_id)
         ngrids_local = grid_end - grid_start
-        print("printing ngrids_local:", ngrids_local, grid_end, grid_start)
         log.debug1(f"{ngrids_local} grids on Device {device_id}")
         if ngrids_local <= 0:
             return cupy.zeros((nao, nao)), 0, 0
 
         weights = cupy.empty([ngrids_local])
+        print("1. weights: ", len(weights), weights)
         if xctype == 'LDA':
-            rho_tot = cupy.empty([1,ngrids_local])
+            rho_tot = cupy.zeros([1,ngrids_local])
         elif xctype == 'GGA':
             rho_tot = cupy.empty([4,ngrids_local])
         else:
             rho_tot = cupy.empty([5,ngrids_local])
 
+        print("1. rho_tot[0]: ", xctype, ngrids_local, rho_tot.shape, len(rho_tot[0]), rho_tot[0])
+
         if mo_coeff is None:
             buf = cupy.empty(MIN_BLK_SIZE * nao)
-            dm_mask_buf = cupy.empty(nao*nao)
+            dm_mask_buf = cupy.zeros(nao*nao)
+            print("0. type of dm_mask_buf: ", type(dm_mask_buf), dm_mask_buf.shape, dm_mask_buf)
         else:
             mo_coeff = cupy.asarray(mo_coeff[:,mo_occ>0], order='C')
             mo_coeff *= mo_occ[mo_occ>0]**.5
@@ -489,36 +497,39 @@ def _nr_rks_task(ni, mol, grids, xc_code, dm, mo_coeff, mo_occ,
             #TODO: If AO is sparse enough, use density matrix to calculate rho
             if mo_coeff is None:
                 dm_mask = dm_mask_buf[:nao_sub**2].reshape(nao_sub,nao_sub)
-                print("printing value of idx from numint.py:" , len(idx), nao_sub)
+                print("1. type of dm_mask: ", type(dm_mask), dm_mask.shape, dm_mask)
                 dm_mask = take_last2d(dm, idx, out=dm_mask)
+                print("2. type of dm_mask: ", type(dm_mask), dm_mask.shape, dm_mask)
+                print("2. type of ao_mask: ", type(ao_mask), ao_mask.shape, ao_mask)
                 rho_tot[:,p0:p1] = eval_rho(_sorted_mol, ao_mask, dm_mask,
                                             xctype=xctype, hermi=hermi,
                                             with_lapl=with_lapl, buf=buf)
+                print("2. rho_tot[0]: ", len(rho_tot[0]), rho_tot[0])
             else:
                 assert hermi == 1
                 cpos = mo_buf[:nao_sub*nocc].reshape(nao_sub,nocc)
                 cpos = cupy.take(mo_coeff, idx, axis=0, out=cpos)
                 rho_tot[:,p0:p1] = _eval_rho2(ao_mask, cpos, xctype, with_lapl, buf)
+                print("3. rho_tot[0]: ", len(rho_tot[0]), rho_tot[0])
         t0 = log.timer_debug1(f'eval rho on Device {device_id}', *t0)
         dm_mask_buf = mo_buf = mo_coeff = None
 
         weights = cupy.asarray(grids.weights[grid_start:grid_end])
-        print("START: weights printing in numint.py: ", type(weights))
-        # for i in range(len(weights)):
-        #     print(weights[i])
-        # for i in range(len(rho_tot[0])):
-        #     print((rho_tot[0])[i])
-        print("STOP: weights printing in numint.py")
         excsum = 0.0
         den = rho_tot[0] * weights
+        print("weights: ", len(weights), weights)
+        print("rho_tot[0]: ", len(rho_tot[0]), rho_tot[0])
+        print("den: ", len(den), den)
         nelec = float(den.sum())
-        print("_nr_rks_task() in numint.py: ", nelec, weights, rho_tot[0], den)
         # libxc calls are still running on default stream
         if xctype != 'HF':
             exc, vxc = ni.eval_xc_eff(xc_code, rho_tot, deriv=1, xctype=xctype)[:2]
             vxc = cupy.asarray(vxc, order='C')
             exc = cupy.asarray(exc, order='C')
             excsum = float(cupy.dot(den, exc[:,0]))
+            print("HERE from libxc vxc: ", type(vxc), len(vxc), vxc)
+            print("HERE from libxc exc: ", type(exc), len(exc), exc)
+            print("HERE from libxc excsum: ", type(excsum), excsum)
             wv = vxc
             wv *= weights
             if xctype == 'GGA':
@@ -529,6 +540,7 @@ def _nr_rks_task(ni, mol, grids, xc_code, dm, mo_coeff, mo_occ,
         t0 = log.timer_debug1(f'eval vxc on Device {device_id}', *t0)
 
         vtmp_buf = cupy.empty(nao*nao)
+        print("1. value of vtmp_buf BEFORE: ", type(vtmp_buf), vtmp_buf)
         vmat = cupy.zeros((nao, nao))
         p0 = p1 = 0
         for ao_mask, idx, weight, _ in ni.block_loop(
@@ -536,13 +548,20 @@ def _nr_rks_task(ni, mol, grids, xc_code, dm, mo_coeff, mo_occ,
                 grid_range=(grid_start, grid_end)):
             p1 = p0 + weight.size
             nao_sub = len(idx)
+            print("2. value of vtmp_buf BEFORE: ", type(vtmp_buf), vtmp_buf)
             vtmp = cupy.ndarray((nao_sub, nao_sub), memptr=vtmp_buf.data)
+            print("value of vtmp AFTER: ", type(vtmp), vtmp)
             if xctype == 'LDA':
                 aow = _scale_ao(ao_mask, wv[0,p0:p1], out=buf)
+                print("value of aow(LDA)", type(aow), aow)
+                print("value of vmat(LDA)", type(vmat), vmat)
+                print("value of idx(LDA)", type(idx), idx)
                 add_sparse(vmat, ao_mask.dot(aow.T, out=vtmp), idx)
+                print("value of vmat(LDA) in _nr_rks_task: ", vmat)
             elif xctype == 'GGA':
                 aow = _scale_ao(ao_mask, wv[:,p0:p1], out=buf)
                 add_sparse(vmat, ao_mask[0].dot(aow.T, out=vtmp), idx)
+                print("value of vmat(GGA) in _nr_rks_task: ", vmat)
             elif xctype == 'NLC':
                 raise NotImplementedError('NLC')
             elif xctype == 'MGGA':
@@ -550,16 +569,19 @@ def _nr_rks_task(ni, mol, grids, xc_code, dm, mo_coeff, mo_occ,
                 aow = _scale_ao(ao_mask, wv[:4,p0:p1], out=buf)
                 vtmp = contract('ig,jg->ij', ao_mask[0], aow, beta=1., out=vtmp)
                 add_sparse(vmat, vtmp, idx)
+                print("value of vmat(MGGA) in _nr_rks_task: ", vmat)
             elif xctype == 'HF':
                 pass
             else:
                 raise NotImplementedError(f'numint.nr_rks for functional {xc_code}')
             p0 = p1
         t0 = log.timer_debug1(f'eval integration on {device_id}', *t0)
+        print("value from _nr_rks_task: ", vmat, nelec, excsum)
     return vmat, nelec, excsum
 
 def nr_rks(ni, mol, grids, xc_code, dms, relativity=0, hermi=1,
            max_memory=2000, verbose=None):
+    print("here in nr_rks")
     log = logger.new_logger(mol, verbose)
     t0 = log.init_timer()
     xctype = ni._xc_type(xc_code)
@@ -593,17 +615,16 @@ def nr_rks(ni, mol, grids, xc_code, dms, relativity=0, hermi=1,
     excsum_dist = []
     for future in futures:
         v, n, e = future.result()
+        print("temp values: ", v, n, e)
         vmat_dist.append(v)
         nelec_dist.append(n)
         excsum_dist.append(e)
     vmat = reduce_to_device(vmat_dist, inplace=True)
     vmat_dist = None
     vmat = opt.unsort_orbitals(vmat, axis=[0,1])
-    print("1. value of nr_rks in numint.py: ", nelec_dist)
     nelec = sum(nelec_dist)
-    print("2. value of nr_rks in numint.py: ", nelec, excsum_dist)
     excsum = sum(excsum_dist)
-    print("3. value of nr_rks in numint.py: ", nelec, excsum)
+
     if xctype != 'LDA':
         transpose_sum(vmat)
 
@@ -611,7 +632,7 @@ def nr_rks(ni, mol, grids, xc_code, dms, relativity=0, hermi=1,
         cupy.get_default_memory_pool().free_all_blocks()
 
     t0 = log.timer_debug1('nr_rks', *t0)
-    print("4. value of nr_rks in numint.py: ", nelec, excsum)
+    print("nelectr value in numint: ", nelec, excsum)
     return nelec, excsum, vmat
 
 def eval_rho_group(mol, ao_group, mo_coeff_group, mo_occ,
@@ -707,6 +728,7 @@ def eval_rho_group(mol, ao_group, mo_coeff_group, mo_occ,
 
 def nr_rks_group(ni, mol, grids, xc_code, dms, relativity=0, hermi=1,
            max_memory=2000, verbose=None):
+    print("here in nr_rks_group")
     log = logger.new_logger(mol, verbose)
     xctype = ni._xc_type(xc_code)
     opt = getattr(ni, 'gdftopt', None)
@@ -1152,6 +1174,7 @@ def _nr_rks_fxc_task(ni, mol, grids, xc_code, fxc, dms, mo1, occ_coeff,
 
 def nr_rks_fxc(ni, mol, grids, xc_code, dm0=None, dms=None, relativity=0, hermi=0,
                rho0=None, vxc=None, fxc=None, max_memory=2000, verbose=None):
+    print("here in nr_rks_fxc")
     log = logger.new_logger(mol, verbose)
     t0 = log.init_timer()
     if fxc is None:
@@ -1202,6 +1225,7 @@ def nr_rks_fxc(ni, mol, grids, xc_code, dm0=None, dms=None, relativity=0, hermi=
 def nr_rks_fxc_st(ni, mol, grids, xc_code, dm0=None, dms_alpha=None,
                   relativity=0, singlet=True, rho0=None, vxc=None, fxc=None,
                   max_memory=2000, verbose=None):
+    print("here in nr_rks_fxc_st")
     if fxc is None:
         raise RuntimeError('fxc was not initialized')
     if singlet:
@@ -1329,7 +1353,6 @@ def nr_uks_fxc(ni, mol, grids, xc_code, dm0=None, dms=None, relativity=0, hermi=
     dma, dmb = dms
     dm_shape = dma.shape
     nao = dm_shape[-1]
-    # AO basis -> gdftopt AO basis
     with_mocc = hasattr(dms, 'mo1')
     mo1 = occ_coeff = None
     if with_mocc:
@@ -1383,6 +1406,23 @@ def nr_uks_fxc(ni, mol, grids, xc_code, dm0=None, dms=None, relativity=0, hermi=
     vmat = cupy.asarray([vmata, vmatb])
     return vmat
 
+def _contract_rho1_fxc(rho1, fxc):
+    '''
+    contract('nxg,yxg->nyg', nrho1, fxc) for RKS
+    contract('nsxg,tysxg->ntyg', rho1, fxc) for UKS
+    '''
+    # The cutensor contract or einsum has high overhead for small tensors
+    nvar, ngrids = fxc.shape[-2:]
+    output_shape = rho1.shape
+    if fxc.ndim == 3: # RKS
+        rho1 = rho1.reshape(-1,1,nvar,ngrids)
+    else:
+        nv2 = nvar * 2
+        rho1 = rho1.reshape(-1,1,nv2,ngrids)
+        fxc = fxc.reshape(nv2,nv2,ngrids)
+    out = (rho1 * fxc).sum(axis=2)
+    return out.reshape(output_shape)
+
 def nr_nlc_vxc(ni, mol, grids, xc_code, dms, relativity=0, hermi=1,
                max_memory=2000, verbose=None):
     '''Calculate NLC functional and potential matrix on given grids
@@ -1539,51 +1579,84 @@ def cache_xc_kernel(ni, mol, grids, xc_code, mo_coeff, mo_occ, spin=0,
     t0 = log.timer_debug1('eval fxc', *t0)
     return rho, vxc, fxc
 
-#ABB: This fuse() is commented for SYCL backend since no
-# functionality exists in DPNP/DPCTL
 #@cupy.fuse()
 def batch_square(a):
     return a[0]**2 + a[1]**2 + a[2]**2
 
-def eval_xc_eff(ni, xc_code, rho, deriv=1, omega=None, xctype=None, verbose=None):
+def batch_square_inplace(a, out=None):
+    if out is None:
+        out = cupy.empty_like(a[0])
+    cupy.square(a[0], out=out)
+    out += a[1] * a[1]
+    out += a[2] * a[2]
+    return out
+
+def eval_xc_eff(ni, xc_code, rho, deriv=1, omega=None, xctype=None,
+                verbose=None, spin=None, buf=None):
     '''
     Different from PySCF, this function employ cuda version libxc
     '''
     if omega is None: omega = ni.omega
     if xctype is None: xctype = ni._xc_type(xc_code)
 
-    spin_polarized = rho.ndim >= 2 and rho.shape[0] == 2
-    xcfuns = ni._init_xcfuns(xc_code, spin_polarized)
-
+    if spin is None:
+        spin_polarized = rho.ndim >= 2 and rho.shape[0] == 2
+        if spin_polarized:
+            spin = 1
+        else:
+            spin = 0
+    xcfuns = ni._init_xcfuns(xc_code, spin)
     inp = {}
-    if not spin_polarized:
+    if spin == 0:
         assert rho.dtype == np.float64
+        ngrids = rho.shape[-1]
         if xctype == 'LDA':
             inp['rho'] = rho.ravel()
-        if xctype == 'GGA':
-            inp['rho'] = rho[0]
-            inp['sigma'] = batch_square(rho[1:4])
-        if xctype == 'MGGA':
+        elif xctype in ['GGA', 'MGGA']:
             inp['rho'] = rho[0]
-            inp['sigma'] = batch_square(rho[1:4])
-            inp['tau'] = rho[-1]     # can be 4 (without laplacian) or 5 (with laplacian)
+            sigma1 = ndarray(ngrids, buffer=buf)
+            inp['sigma'] = batch_square_inplace(rho[1:4], out=sigma1)
+            if xctype == 'MGGA':
+                inp['tau'] = rho[-1]     # can be 4 (without laplacian) or 5 (with laplacian)
     else:
         assert rho[0].dtype == np.float64
+        ngrids = rho.shape[-1]
         if xctype == 'LDA':
-            inp['rho'] = cupy.stack([rho[0].ravel(), rho[1].ravel()], axis=1)
-        if xctype == 'GGA':
-            inp['rho'] = cupy.stack([rho[0,0], rho[1,0]], axis=1)
-            sigma0 = batch_square(rho[0,1:4])
-            sigma1 = rho[0,1]*rho[1,1] + rho[0,2]*rho[1,2] + rho[0,3]*rho[1,3]
-            sigma2 = batch_square(rho[1,1:4])
-            inp['sigma'] = cupy.stack([sigma0, sigma1, sigma2], axis=1)
-        if xctype == 'MGGA':
-            inp['rho'] = cupy.stack([rho[0,0], rho[1,0]], axis=1)
-            sigma0 = batch_square(rho[0,1:4])
-            sigma1 = rho[0,1]*rho[1,1] + rho[0,2]*rho[1,2] + rho[0,3]*rho[1,3]
-            sigma2 = batch_square(rho[1,1:4])
-            inp['sigma'] = cupy.stack([sigma0, sigma1, sigma2], axis=1)
-            inp['tau'] = cupy.stack([rho[0,-1], rho[1,-1]], axis=1)     # can be 4 (without laplacian) or 5 (with laplacian)
+            rho2 = ndarray((ngrids, 2), buffer=buf)
+            rho2[:,0] = rho[0].ravel()
+            rho2[:,1] = rho[1].ravel()
+            inp['rho'] = rho2
+        elif xctype == 'GGA':
+            buf = ndarray((5, ngrids), buffer=buf)
+            rho2 = ndarray((ngrids, 2), buffer=buf[:2])
+            sigma3 = ndarray((ngrids, 3), buffer=buf[2:])
+            rho2[:,0] = rho[0,0]
+            rho2[:,1] = rho[1,0]
+            inp['rho'] = rho2
+            batch_square_inplace(rho[0, 1:4], out=sigma3[:, 0])
+            cupy.multiply(rho[0, 1], rho[1, 1], out=sigma3[:, 1])
+            sigma3[:, 1] += rho[0,2]*rho[1,2]
+            sigma3[:, 1] += rho[0,3]*rho[1,3]
+            batch_square_inplace(rho[1, 1:4], out=sigma3[:, 2])
+            inp['sigma'] = sigma3
+        else: # MGGA
+            buf = ndarray((7, ngrids), buffer=buf)
+            rho2 = ndarray((ngrids, 2), buffer=buf[:2])
+            sigma3 = ndarray((ngrids, 3), buffer=buf[2:5])
+            tau2 = ndarray((ngrids, 2), buffer=buf[5:])
+            rho2[:,0] = rho[0,0]
+            rho2[:,1] = rho[1,0]
+            inp['rho'] = rho2
+            batch_square_inplace(rho[0, 1:4], out=sigma3[:, 0])
+            cupy.multiply(rho[0, 1], rho[1, 1], out=sigma3[:, 1])
+            sigma3[:, 1] += rho[0,2]*rho[1,2]
+            sigma3[:, 1] += rho[0,3]*rho[1,3]
+            batch_square_inplace(rho[1, 1:4], out=sigma3[:, 2])
+            inp['sigma'] = sigma3
+            tau2[:, 0] = rho[0,-1]
+            tau2[:, 1] = rho[1,-1]
+            inp['tau'] = tau2     # can be 4 (without laplacian) or 5 (with laplacian)
+
     do_vxc = True
     do_fxc = deriv > 1
     do_kxc = deriv > 2
@@ -1616,23 +1689,16 @@ def eval_xc_eff(ni, xc_code, rho, deriv=1, omega=None, xctype=None, verbose=None
     kxc = None
 
     exc = ret_full["zk"]
-    if not spin_polarized:
-        vxc = [ret_full[label] for label in vxc_labels if label in ret_full]
-        if do_fxc:
-            fxc = [ret_full[label] for label in fxc_labels if label in ret_full]
-        if do_kxc:
-            kxc = [ret_full[label] for label in kxc_labels if label in ret_full]
-    else:
-        vxc = [ret_full[label] for label in vxc_labels if label in ret_full]
-        if do_fxc:
-            fxc = [ret_full[label] for label in fxc_labels if label in ret_full]
-        if do_kxc:
-            kxc = [ret_full[label] for label in kxc_labels if label in ret_full]
+    vxc = [ret_full[label] for label in vxc_labels if label in ret_full]
+    if do_fxc:
+        fxc = [ret_full[label] for label in fxc_labels if label in ret_full]
+    if do_kxc:
+        kxc = [ret_full[label] for label in kxc_labels if label in ret_full]
     if do_kxc:
-        kxc = xc_deriv.transform_kxc(rho, fxc, kxc, xctype, spin_polarized)
+        kxc = xc_deriv.transform_kxc(rho, fxc, kxc, xctype, spin)
     if do_fxc:
-        fxc = xc_deriv.transform_fxc(rho, vxc, fxc, xctype, spin_polarized)
-    vxc = xc_deriv.transform_vxc(rho, vxc, xctype, spin_polarized)
+        fxc = xc_deriv.transform_fxc(rho, vxc, fxc, xctype, spin)
+    vxc = xc_deriv.transform_vxc(rho, vxc, xctype, spin)
     return exc, vxc, fxc, kxc
 
 def _init_xcfuns(xc_code, spin):
@@ -1775,10 +1841,11 @@ def _block_loop(ni, mol, grids, nao=None, deriv=0, max_memory=2000,
     nao_max = max(len(x[1]) for x in non0ao_idx[block_start:block_end])
     buf = cupy.empty((comp, nao_max, MIN_BLK_SIZE), order='C')
 
-    print("buf stats: ", comp, nao_max, MIN_BLK_SIZE, buf.data)
-    
     for block_id in range(block_start, block_end):
         pad, idx, non0shl_idx, ctr_offsets_slice, ao_loc_slice = non0ao_idx[block_id]
+        print("In _block_loop(): non0shl_idx value in eval_ao: ", non0shl_idx.dtype.name, non0shl_idx.flags['C_CONTIGUOUS'], type(non0shl_idx), len(non0shl_idx), non0shl_idx)
+        print("In _block_loop(): ao_loc_slice value in eval_ao: ", ao_loc_slice.dtype.name, ao_loc_slice.flags['C_CONTIGUOUS'], type(ao_loc_slice), len(ao_loc_slice), ao_loc_slice)
+        print("In _block_loop(): ctr_offsets_slice value in eval_ao: ", ctr_offsets_slice.dtype.name, ctr_offsets_slice.flags['C_CONTIGUOUS'], type(ctr_offsets_slice), len(ctr_offsets_slice), ctr_offsets_slice)
         nao_sub = len(idx)
 
         if nao_sub == 0:
@@ -1786,11 +1853,10 @@ def _block_loop(ni, mol, grids, nao=None, deriv=0, max_memory=2000,
 
         ip0 = block_id * MIN_BLK_SIZE
         ip1 = min(ip0 + MIN_BLK_SIZE, ngrids)
-        print("1. ip0, ip1: ", ip0, ip1, block_id, MIN_BLK_SIZE, ngrids)
         coords = cupy.asarray(grids.coords[ip0:ip1])
-        print("2. ip0, ip1: ", ip0, ip1, nao_sub)            
         weight = cupy.asarray(grids.weights[ip0:ip1])
-        
+        print("value of coords from block_loop: ", len(coords), coords)
+        print("value of weight from block_loop: ", len(weight), weight)
         ao_mask = eval_ao(
             _sorted_mol, coords, deriv,
             nao_slice=len(idx),
@@ -1800,7 +1866,7 @@ def _block_loop(ni, mol, grids, nao=None, deriv=0, max_memory=2000,
             gdftopt=opt,
             transpose=False,
             out=cupy.ndarray((comp,nao_sub,ip1-ip0), memptr=buf.data))
-
+        print("value of ao_mask from block_loop: ", type(ao_mask), ao_mask.shape, ao_mask)
         if pad > 0:
             if deriv == 0:
                 ao_mask[-pad:,:] = 0.0
@@ -1957,7 +2023,6 @@ def _contract_rho(bra, ket, rho=None):
     if bra.flags.c_contiguous and ket.flags.c_contiguous:
         assert bra.shape == ket.shape
         nao, ngrids = bra.shape
-        print("values from _contract_rho in num_int.py", nao, ngrids)
         if rho is None:
             rho = cupy.empty(ngrids)
         stream = cupy.cuda.get_current_stream()
@@ -1970,7 +2035,9 @@ def _contract_rho(bra, ket, rho=None):
         if err != 0:
             raise RuntimeError('CUDA Error')
     else:
-        rho = contract('ig,ig->g', bra, ket)
+        if rho is None:
+            rho = cupy.empty(ngrids)
+        contract('ig,ig->g', bra, ket, out=rho)
     return rho
 
 def _contract_rho1(bra, ket, rho=None):
@@ -2110,23 +2177,20 @@ def _tau_dot_sparse(bra, ket, wv, nbins, screen_index, ao_loc,
 
 def _scale_ao(ao, wv, out=None):
     if wv.ndim == 1:
-        if ao.flags.f_contiguous or ao.dtype != np.float64:
-            assert out is None
-            return ao * wv
         nvar = 1
         nao, ngrids = ao.shape
         assert wv.size == ngrids
+        out = ndarray((nao, ngrids), dtype=ao.dtype, buffer=out)
+        if not ao.flags.c_contiguous or ao.dtype != np.float64:
+            return cupy.multiply(ao, wv, out=out)
     else:
-        if ao[0].flags.f_contiguous or ao.dtype != np.float64:
-            return contract('nip,np->ip', ao, wv, out=out)
         nvar, nao, ngrids = ao.shape
         assert wv.shape == (nvar, ngrids)
+        out = ndarray((nao, ngrids), dtype=ao.dtype, buffer=out)
+        if not ao[0].flags.c_contiguous or ao.dtype != np.float64:
+            return contract('nip,np->ip', ao, wv, out=out)
 
     wv = cupy.asarray(wv, order='C')
-    if out is None:
-        out = cupy.empty((nao, ngrids), order='C')
-    else:
-        out = cupy.ndarray((nao, ngrids), dtype=np.float64, memptr=out.data)
     stream = cupy.cuda.get_current_stream()
     err = libgdft.GDFTscale_ao(
         ctypes.cast(stream.ptr, ctypes.c_void_p),
@@ -2140,11 +2204,12 @@ def _scale_ao(ao, wv, out=None):
 
 def _tau_dot(bra, ket, wv, buf=None, out=None):
     '''1/2 <nabla i| v | nabla j>'''
+    # einsum('g,xig,xjg->ij', .5*wv, bra[1:4], ket[1:4])
     wv = cupy.asarray(.5 * wv)
-    mat = contract('ig,jg->ij', bra[1], _scale_ao(ket[1], wv, out=buf), out=out)
-    mat = contract('ig,jg->ij', bra[2], _scale_ao(ket[2], wv, out=buf), beta=1., out=mat)
-    mat = contract('ig,jg->ij', bra[3], _scale_ao(ket[3], wv, out=buf), beta=1., out=mat)
-    return mat
+    out = contract('ig,jg->ij', bra[1], _scale_ao(ket[1], wv, out=buf), out=out)
+    out = contract('ig,jg->ij', bra[2], _scale_ao(ket[2], wv, out=buf), beta=1., out=out)
+    out = contract('ig,jg->ij', bra[3], _scale_ao(ket[3], wv, out=buf), beta=1., out=out)
+    return out
 
 class _GDFTOpt:
     def __init__(self, mol):
