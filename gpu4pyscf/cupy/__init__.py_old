# Copyright 2021-2024 The PySCF Developers. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

print("Inside custom cupy/__init__.py")

import sys
import types
import abc
import dpnp
import numpy as np
import dpnp.dpnp_array
import dpctl.tensor as dpt

# Create a API specifically for `memptr` arg that is not
# supported from DPNP APIs
# class FakeCupyNdarray(dpnp.ndarray, abc.ABC):
#     def get(self):
#         return dpnp.asnumpy(self)

#     def set(self, host_array):
#         self[...] = host_array

#     def __new__(cls, shape, dtype=np.float64, memptr=None):
#         if memptr is None:
#             obj = dpnp.ndarray.__new__(cls, shape, dtype=dtype)
#         else:
#             itemsize = np.dtype(dtype).itemsize
#             strides = tuple(s * itemsize for s in reversed(np.cumprod((1,) + shape[:-1])[::-1]))
#             if isinstance(memptr, ctypes.c_void_p):
#                 memptr = memptr.value
#             usm_arr = dpt.usm_ndarray(
#                 shape=shape,
#                 dtype=dtype,
#                 buffer=memptr,
#                 strides=strides,
#                 usm_type="device",
#                 queue=dpctl.SyclQueue()
#             )
#             obj = dpnp.asarray(usm_arr).view(cls)
#         return obj

# # Register dpnp array class as virtual subclass
# FakeCupyNdarray.register(dpnp.dpnp_array.dpnp_array)

# # Set up fake cupy module
# cupy_fake = types.ModuleType("cupy")
# cupy_fake.ndarray = FakeCupyNdarray

class FakeCupyNdarray(dpnp.ndarray):
    def get(self):
        return dpnp.asnumpy(self)

    def set(self, host_array):
        self[...] = host_array

    def __new__(cls, shape, dtype=np.float64, memptr=None):
        if memptr is None:
            # Regular dpnp allocation
            obj = dpnp.ndarray.__new__(cls, shape, dtype=dtype)
        else:
            # Use USM pointer from memptr
            itemsize = np.dtype(dtype).itemsize
            strides = tuple(s * itemsize for s in reversed(np.cumprod((1,) + shape[:-1])[::-1]))
            if isinstance(memptr, ctypes.c_void_p):
                memptr = memptr.value
            usm_arr = dpt.usm_ndarray(
                shape=shape,
                dtype=dtype,
                buffer=memptr,
                strides=strides,
                usm_type="device",
                queue=dpctl.SyclQueue()
            )
            obj = dpnp.asarray(usm_arr).view(cls)
        return obj

# Create a new module object to act as "cupy"
cupy_fake = types.ModuleType("cupy")


# Populate it with selected dpnp functions
for attr in ["ndarray", "max", "dot", "linalg", "concatenate", "asarray", "zeros", "ones", "array", "empty", "eye", "einsum", "hstack", "view", "empty_like", "copyto", "vstack", "full", "arange", "asnumpy", "stack", "expand_dims", "unique", "double"]:

    try:
        if attr == "ndarray":
            setattr(cupy_fake, attr, FakeCupyNdarray)
            print("Set cupy.ndarray to custom constructor with memptr support")
        else:
            setattr(cupy_fake, attr, getattr(dpnp, attr))
            print(f"Set cupy.{attr} from dpnp.{attr}")
    except AttributeError:
        print(f"dpnp does not have {attr}, skipping.")

# Define get() and set() methods that mimic CuPy behavior
def _dpnp_get(self):
    """Mimics CuPy's ndarray.get()"""
    return dpnp.asnumpy(self)

def _dpnp_set(self, host_array):
    """Mimics CuPy's ndarray.set()"""
    self[...] = host_array

# Inject as methods on dpnp.ndarray
dpnp.ndarray.get = _dpnp_get
dpnp.ndarray.set = _dpnp_set

# Also provide module-level get(x) and set(x, host_array) as alternatives
def get(x):
    return x.get() if isinstance(x, dpnp.ndarray) else x

def set(x, host_array):
    if isinstance(x, dpnp.ndarray):
        x.set(host_array)
    else:
        raise TypeError(f"set() only supports dpnp arrays, got {type(x)}")

cupy_fake.get = get
cupy_fake.set = set

# (Optional) add submodules like `cuda` if needed
try:
    from . import cuda
    cupy_fake.cuda = cuda
except ImportError as e:
    print(f"Could not import .cuda: {e}")

# Show before injecting
print("Before sys.modules['cupy'] =", sys.modules.get("cupy", "NOT FOUND"))

# Register this fake module
sys.modules["cupy"] = cupy_fake

# After injection
print("After sys.modules['cupy'] =", sys.modules["cupy"])
print("cupy.einsum =", getattr(sys.modules["cupy"], "einsum", "NOT FOUND"))
